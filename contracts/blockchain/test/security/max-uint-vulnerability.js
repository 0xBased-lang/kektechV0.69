/**
 * @fileoverview Test for MAX_UINT256 Resolution Time Vulnerability
 */

const { expect } = require("chai");
const { ethers } = require("hardhat");
const fs = require("fs");
const path = require("path");

describe("ğŸš¨ MAX_UINT256 VULNERABILITY TEST", function () {
    it("CRITICAL: Market accepts MAX_UINT256 resolution time (funds locked forever)", async function () {
        const [deployer] = await ethers.getSigners();

        // Load deployment
        const deploymentPath = path.join(__dirname, "../../deployments/fork-deployment.json");
        const deployment = JSON.parse(fs.readFileSync(deploymentPath, "utf8"));

        const marketFactory = await ethers.getContractAt(
            "FlexibleMarketFactory",
            deployment.contracts.marketFactory
        );

        const MAX_UINT256 = ethers.MaxUint256;
        const MIN_CREATOR_BOND = ethers.parseEther("0.01");

        console.log("\n        Testing market creation with MAX_UINT256 resolution time...");
        console.log(`        MAX_UINT256 = ${MAX_UINT256}`);
        console.log(`        This is year ${new Date(Number(MAX_UINT256) * 1000).getFullYear()} (practically never!)`);

        // Try to create market with MAX_UINT256 resolution time
        const tx = await marketFactory.createMarket(
            {
                question: "Will this market ever resolve?",
                description: "Market with MAX_UINT256 resolution time",
                resolutionTime: MAX_UINT256,
                creatorBond: MIN_CREATOR_BOND,
                category: ethers.keccak256(ethers.toUtf8Bytes("TEST")),
                outcome1: "Yes",
                outcome2: "No",
            },
            { value: MIN_CREATOR_BOND }
        );

        const receipt = await tx.wait();

        // Find the MarketCreated event
        const event = receipt.logs.find(log => {
            try {
                return marketFactory.interface.parseLog(log).name === "MarketCreated";
            } catch {
                return false;
            }
        });

        if (event) {
            const marketAddress = marketFactory.interface.parseLog(event).args.marketAddress;
            const market = await ethers.getContractAt("PredictionMarket", marketAddress);

            const resolutionTime = await market.resolutionTime();

            console.log("\n        ğŸš¨ğŸš¨ğŸš¨ CRITICAL VULNERABILITY CONFIRMED! ğŸš¨ğŸš¨ğŸš¨");
            console.log(`        âŒ Market created with resolution time: ${resolutionTime}`);
            console.log(`        âŒ This market can NEVER be resolved!`);
            console.log(`        âŒ Any funds bet on this market are LOCKED FOREVER!`);

            // Verify users can bet (locking funds forever)
            const MIN_BET = ethers.parseEther("0.001");
            await market.connect(deployer).placeBet(1, 0, { value: MIN_BET });

            console.log(`        âŒ User successfully bet ${MIN_BET} wei - these funds are now UNRECOVERABLE!`);
            console.log("\n        RECOMMENDATION: Add maximum resolution time check in createMarket()");
            console.log("        SUGGESTED FIX: Limit resolution time to current + 2 years maximum");
        }
    });
});